---
title: "basic-principals.md"
time: "2025-04-25 :: 14:38:05"
tags: 
---

## unix philosophy

- Write programs that do one thing and do it well.
- Write programs to work together.
- Write programs to handle text streams, because that is a universal interface.

## zen of python

- Beautiful is better than ugly.
- Explicit is better than implicit.
- Simple is better than complex.
- Complex is better than complicated.
- Flat is better than nested.
- Sparse is better than dense.
- Readability counts.
- Special cases aren't special enough to break the rules.
- Although practicality beats purity.
- Errors should never pass silently.
- Unless explicitly silenced.
- In the face of ambiguity, refuse the temptation to guess.
- There should be one-- and preferably only one --obvious way to do it.
- Although that way may not be obvious at first unless you're Dutch.
- Now is better than never.
- Although never is often better than *right* now.
- If the implementation is hard to explain, it's a bad idea.
- If the implementation is easy to explain, it may be a good idea.
- Namespaces are one honking great idea -- let's do more of those!

## ACID

- atomicity
- consistency
- isolation
- durability

## Do what I mean (DWIM)

## Don't repeat yourself (DRY)

## Egoless programming

## Fail-fast

## Big ball of mud

## Gall's law

A complex system that works is invariably found to have evolved from a simple system that worked. A complex system designed from scratch never works and cannot be patched up to make it work. You have to start over with a working simple system.

## If it ain't broke, don't fix it

## Keep It Simple Stupid! (KISS) principle

## Ninety–ninety rule

The first 90 percent of the code accounts for the first 90 percent of the development time. The remaining 10 percent of the code accounts for the other 90 percent of the development time.

## Pareto principle

The Pareto principle also known as the 80/20 rule, the law of the vital few and the principle of factor sparsity states that for many outcomes, roughly 80% of consequences come from 20% of causes the "vital few".

## Parkinson's law

work expands so as to fill the time available for its completion

## Principle of least astonishment (POLA)

a component of a system should behave in a way that most users will expect it to behave, and therefore not astonish or surprise users.

## Robustness principle, also known as Postel's law

be conservative in what you do, be liberal in what you accept from others.

## Rule of least power

suggests choosing the least powerful computer language suitable for a given purpose.

## Separation of concerns

## Single source of truth (SSOT)

## SOLID (object-oriented design)

- Single responsibility principle: there should never be more than one reason for a class to change or every class should have only one responsibility.
- Open–closed principle: software entities ... should be open for extension, but closed for modification.
- Liskov substitution principle: functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.
- Dependency inversion principle: depend upon abstractions, [not] concretes.

## There's more than one way to do it

## Worse is better

## You aren't gonna need it (YAGNI)
